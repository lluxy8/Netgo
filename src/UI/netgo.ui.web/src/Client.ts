//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export interface IClient {

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body?: AuthRequest | undefined): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    register(body?: RegistrationRequest | undefined): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    passwordresettoken(id: string, body?: string | undefined): Promise<void>;

    /**
     * @param token (optional) 
     * @param body (optional) 
     * @return OK
     */
    passwordreset(id: string, token?: string | undefined, body?: string | undefined): Promise<void>;

    /**
     * @return OK
     */
    emailconfirmtoken(id: string): Promise<void>;

    /**
     * @param token (optional) 
     * @return OK
     */
    emailconfirm(id: string, token?: string | undefined): Promise<void>;

    /**
     * @return OK
     */
    categoriesGET(id: string): Promise<void>;

    /**
     * @return OK
     */
    categoriesDELETE(id: string): Promise<void>;

    /**
     * @return OK
     */
    categoriesGET2(): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    categoriesPOST(body?: CategoryCreateDTO | undefined): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    categoriesPUT(body?: CategoryUpdateDTO | undefined): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    chatPOST(body?: CreateMessageDTO | undefined): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    chatPUT(body?: UpdateMessageDTO | undefined): Promise<void>;

    /**
     * @return OK
     */
    chatGET(id: string): Promise<void>;

    /**
     * @return OK
     */
    user(id: string): Promise<void>;

    /**
     * @return OK
     */
    anonymous(id: string): Promise<void>;

    /**
     * @param title (optional) 
     * @param categoryId (optional) 
     * @param priceMin (optional) 
     * @param priceMax (optional) 
     * @param priceFixed (optional) 
     * @param tradable (optional) 
     * @param sold (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    productsGET(title?: string | undefined, categoryId?: string | undefined, priceMin?: number | undefined, priceMax?: number | undefined, priceFixed?: number | undefined, tradable?: boolean | undefined, sold?: boolean | undefined, page?: number | undefined, pageSize?: number | undefined): Promise<void>;

    /**
     * @param userId (optional) 
     * @param categoryId (optional) 
     * @param tradable (optional) 
     * @param price (optional) 
     * @param details (optional) 
     * @param images (optional) 
     * @return OK
     */
    productsPOST(title: string, description: string, userId?: string | undefined, categoryId?: string | undefined, tradable?: boolean | undefined, price?: number | undefined, details?: ProductDetailDto[] | undefined, images?: FileParameter[] | undefined): Promise<void>;

    /**
     * @param id (optional) 
     * @param categoryId (optional) 
     * @param tradable (optional) 
     * @param details (optional) 
     * @param images (optional) 
     * @param newImages (optional) 
     * @return OK
     */
    productsPUT(title: string, description: string, id?: string | undefined, categoryId?: string | undefined, tradable?: boolean | undefined, details?: ProductDetailDto[] | undefined, images?: string[] | undefined, newImages?: FileParameter[] | undefined): Promise<void>;

    /**
     * @return OK
     */
    productsGET2(id: string): Promise<void>;

    /**
     * @return OK
     */
    user2(userId: string): Promise<void>;

    /**
     * @return OK
     */
    usersGET(id: string): Promise<void>;

    /**
     * @param id (optional) 
     * @param firstName (optional) 
     * @param lastName (optional) 
     * @param contactInfo (optional) 
     * @param profilePicture (optional) 
     * @return OK
     */
    usersPUT(id?: string | undefined, firstName?: string | undefined, lastName?: string | undefined, contactInfo?: string | undefined, profilePicture?: FileParameter | undefined): Promise<void>;
}

export class Client implements IClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body?: AuthRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    register(body?: RegistrationRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    passwordresettoken(id: string, body?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/passwordresettoken/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPasswordresettoken(_response);
        });
    }

    protected processPasswordresettoken(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param token (optional) 
     * @param body (optional) 
     * @return OK
     */
    passwordreset(id: string, token?: string | undefined, body?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/passwordreset/{id}?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (token === null)
            throw new globalThis.Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPasswordreset(_response);
        });
    }

    protected processPasswordreset(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    emailconfirmtoken(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/emailconfirmtoken/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEmailconfirmtoken(_response);
        });
    }

    protected processEmailconfirmtoken(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param token (optional) 
     * @return OK
     */
    emailconfirm(id: string, token?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/emailconfirm/{id}?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (token === null)
            throw new globalThis.Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEmailconfirm(_response);
        });
    }

    protected processEmailconfirm(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    categoriesGET(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/categories/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCategoriesGET(_response);
        });
    }

    protected processCategoriesGET(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    categoriesDELETE(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/categories/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCategoriesDELETE(_response);
        });
    }

    protected processCategoriesDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    categoriesGET2(): Promise<void> {
        let url_ = this.baseUrl + "/api/categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCategoriesGET2(_response);
        });
    }

    protected processCategoriesGET2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    categoriesPOST(body?: CategoryCreateDTO | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCategoriesPOST(_response);
        });
    }

    protected processCategoriesPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    categoriesPUT(body?: CategoryUpdateDTO | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCategoriesPUT(_response);
        });
    }

    protected processCategoriesPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    chatPOST(body?: CreateMessageDTO | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/chat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChatPOST(_response);
        });
    }

    protected processChatPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    chatPUT(body?: UpdateMessageDTO | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/chat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChatPUT(_response);
        });
    }

    protected processChatPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    chatGET(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/chat/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChatGET(_response);
        });
    }

    protected processChatGET(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    user(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/chat/user/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUser(_response);
        });
    }

    protected processUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    anonymous(id: string): Promise<void> {
        let url_ = this.baseUrl + "/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAnonymous(_response);
        });
    }

    protected processAnonymous(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param title (optional) 
     * @param categoryId (optional) 
     * @param priceMin (optional) 
     * @param priceMax (optional) 
     * @param priceFixed (optional) 
     * @param tradable (optional) 
     * @param sold (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    productsGET(title?: string | undefined, categoryId?: string | undefined, priceMin?: number | undefined, priceMax?: number | undefined, priceFixed?: number | undefined, tradable?: boolean | undefined, sold?: boolean | undefined, page?: number | undefined, pageSize?: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/products?";
        if (title === null)
            throw new globalThis.Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        if (categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (priceMin === null)
            throw new globalThis.Error("The parameter 'priceMin' cannot be null.");
        else if (priceMin !== undefined)
            url_ += "PriceMin=" + encodeURIComponent("" + priceMin) + "&";
        if (priceMax === null)
            throw new globalThis.Error("The parameter 'priceMax' cannot be null.");
        else if (priceMax !== undefined)
            url_ += "PriceMax=" + encodeURIComponent("" + priceMax) + "&";
        if (priceFixed === null)
            throw new globalThis.Error("The parameter 'priceFixed' cannot be null.");
        else if (priceFixed !== undefined)
            url_ += "PriceFixed=" + encodeURIComponent("" + priceFixed) + "&";
        if (tradable === null)
            throw new globalThis.Error("The parameter 'tradable' cannot be null.");
        else if (tradable !== undefined)
            url_ += "Tradable=" + encodeURIComponent("" + tradable) + "&";
        if (sold === null)
            throw new globalThis.Error("The parameter 'sold' cannot be null.");
        else if (sold !== undefined)
            url_ += "Sold=" + encodeURIComponent("" + sold) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductsGET(_response);
        });
    }

    protected processProductsGET(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param userId (optional) 
     * @param categoryId (optional) 
     * @param tradable (optional) 
     * @param price (optional) 
     * @param details (optional) 
     * @param images (optional) 
     * @return OK
     */
    productsPOST(title: string, description: string, userId?: string | undefined, categoryId?: string | undefined, tradable?: boolean | undefined, price?: number | undefined, details?: ProductDetailDto[] | undefined, images?: FileParameter[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/products?";
        if (title === undefined || title === null)
            throw new globalThis.Error("The parameter 'title' must be defined and cannot be null.");
        else
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        if (description === undefined || description === null)
            throw new globalThis.Error("The parameter 'description' must be defined and cannot be null.");
        else
            url_ += "Description=" + encodeURIComponent("" + description) + "&";
        if (userId === null)
            throw new globalThis.Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (tradable === null)
            throw new globalThis.Error("The parameter 'tradable' cannot be null.");
        else if (tradable !== undefined)
            url_ += "Tradable=" + encodeURIComponent("" + tradable) + "&";
        if (price === null)
            throw new globalThis.Error("The parameter 'price' cannot be null.");
        else if (price !== undefined)
            url_ += "Price=" + encodeURIComponent("" + price) + "&";
        if (details === null)
            throw new globalThis.Error("The parameter 'details' cannot be null.");
        else if (details !== undefined)
            details && details.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Details[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (images === null || images === undefined)
            throw new globalThis.Error("The parameter 'images' cannot be null.");
        else
            images.forEach(item_ => content_.append("Images", item_.data, item_.fileName ? item_.fileName : "Images") );

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductsPOST(_response);
        });
    }

    protected processProductsPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param categoryId (optional) 
     * @param tradable (optional) 
     * @param details (optional) 
     * @param images (optional) 
     * @param newImages (optional) 
     * @return OK
     */
    productsPUT(title: string, description: string, id?: string | undefined, categoryId?: string | undefined, tradable?: boolean | undefined, details?: ProductDetailDto[] | undefined, images?: string[] | undefined, newImages?: FileParameter[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/products?";
        if (title === undefined || title === null)
            throw new globalThis.Error("The parameter 'title' must be defined and cannot be null.");
        else
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        if (description === undefined || description === null)
            throw new globalThis.Error("The parameter 'description' must be defined and cannot be null.");
        else
            url_ += "Description=" + encodeURIComponent("" + description) + "&";
        if (id === null)
            throw new globalThis.Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (tradable === null)
            throw new globalThis.Error("The parameter 'tradable' cannot be null.");
        else if (tradable !== undefined)
            url_ += "Tradable=" + encodeURIComponent("" + tradable) + "&";
        if (details === null)
            throw new globalThis.Error("The parameter 'details' cannot be null.");
        else if (details !== undefined)
            details && details.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Details[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (images === null)
            throw new globalThis.Error("The parameter 'images' cannot be null.");
        else if (images !== undefined)
            images && images.forEach(item => { url_ += "Images=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (newImages === null || newImages === undefined)
            throw new globalThis.Error("The parameter 'newImages' cannot be null.");
        else
            newImages.forEach(item_ => content_.append("NewImages", item_.data, item_.fileName ? item_.fileName : "NewImages") );

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductsPUT(_response);
        });
    }

    protected processProductsPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    productsGET2(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/products/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductsGET2(_response);
        });
    }

    protected processProductsGET2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    user2(userId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/products/user/{userId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUser2(_response);
        });
    }

    protected processUser2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    usersGET(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersGET(_response);
        });
    }

    protected processUsersGET(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param firstName (optional) 
     * @param lastName (optional) 
     * @param contactInfo (optional) 
     * @param profilePicture (optional) 
     * @return OK
     */
    usersPUT(id?: string | undefined, firstName?: string | undefined, lastName?: string | undefined, contactInfo?: string | undefined, profilePicture?: FileParameter | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/users?";
        if (id === null)
            throw new globalThis.Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (firstName === null)
            throw new globalThis.Error("The parameter 'firstName' cannot be null.");
        else if (firstName !== undefined)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&";
        if (lastName === null)
            throw new globalThis.Error("The parameter 'lastName' cannot be null.");
        else if (lastName !== undefined)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&";
        if (contactInfo === null)
            throw new globalThis.Error("The parameter 'contactInfo' cannot be null.");
        else if (contactInfo !== undefined)
            url_ += "ContactInfo=" + encodeURIComponent("" + contactInfo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (profilePicture === null || profilePicture === undefined)
            throw new globalThis.Error("The parameter 'profilePicture' cannot be null.");
        else
            content_.append("ProfilePicture", profilePicture.data, profilePicture.fileName ? profilePicture.fileName : "ProfilePicture");

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersPUT(_response);
        });
    }

    protected processUsersPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AuthRequest implements IAuthRequest {
    email!: string | undefined;
    password!: string | undefined; 

    constructor(data?: IAuthRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AuthRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IAuthRequest {
    email: string | undefined;
    password: string | undefined;
}

export class CategoryCreateDTO implements ICategoryCreateDTO {
    name!: string | undefined;

    constructor(data?: ICategoryCreateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CategoryCreateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryCreateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICategoryCreateDTO {
    name: string | undefined;
}

export class CategoryUpdateDTO implements ICategoryUpdateDTO {
    id?: string;
    name!: string | undefined;

    constructor(data?: ICategoryUpdateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CategoryUpdateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryUpdateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICategoryUpdateDTO {
    id?: string;
    name: string | undefined;
}

export class CreateMessageDTO implements ICreateMessageDTO {
    from?: string;
    to?: string;
    content!: string | undefined;

    constructor(data?: ICreateMessageDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.from = _data["from"];
            this.to = _data["to"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): CreateMessageDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMessageDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from;
        data["to"] = this.to;
        data["content"] = this.content;
        return data;
    }
}

export interface ICreateMessageDTO {
    from?: string;
    to?: string;
    content: string | undefined;
}

export class ProductDetailDto implements IProductDetailDto {
    title?: string | undefined;
    value?: string | undefined;

    constructor(data?: IProductDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductDetailDto {
    title?: string | undefined;
    value?: string | undefined;
}

export class RegistrationRequest implements IRegistrationRequest {
    firstName!: string | undefined;
    lastName!: string | undefined;
    contactInfo!: string | undefined;
    location!: string | undefined;
    email!: string | undefined;
    password!: string | undefined;
    profilePicture?: string | undefined;

    constructor(data?: IRegistrationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.contactInfo = _data["contactInfo"];
            this.location = _data["location"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.profilePicture = _data["profilePicture"];
        }
    }

    static fromJS(data: any): RegistrationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegistrationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["contactInfo"] = this.contactInfo;
        data["location"] = this.location;
        data["email"] = this.email;
        data["password"] = this.password;
        data["profilePicture"] = this.profilePicture;
        return data;
    }
}

export interface IRegistrationRequest {
    firstName: string | undefined;
    lastName: string | undefined;
    contactInfo: string | undefined;
    location: string | undefined;
    email: string | undefined;
    password: string | undefined;
    profilePicture?: string | undefined;
}

export class UpdateMessageDTO implements IUpdateMessageDTO {
    id?: string;
    content!: string | undefined;

    constructor(data?: IUpdateMessageDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): UpdateMessageDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMessageDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["content"] = this.content;
        return data;
    }
}

export interface IUpdateMessageDTO {
    id?: string;
    content: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}